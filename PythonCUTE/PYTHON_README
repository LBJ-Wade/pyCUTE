=============================================================================
Installation:
=============================================================================

To compile the python module one needs to have SWIG installed
MacOS: [ sudo port install swig-python ]
Otherwise: [ wget http://prdownloads.sourceforge.net/swig/swig-3.0.12.tar.gz ]
SWIG again requires GSL and PCRD. For the latter library one might need to add [-lstdc++] to CPP in the Makefile
generated by configure to allow it to compile. If SWIG cannot find PCRE then export the environment variables
PCRE_LIBS="-L$HOME/local/lib -lpcre" PCRE_CFLAGS="-I$HOME/local/prce-8.42" before compiling SWIG.
If this also failes to compile then one might need to add [-lstdc++] behind [-lpcre] above.

Set paths to Python.h [PYTHONINC] and libpython [PYTHONLIB] for the Python version you intend to run in Makefile.python

The python module is compiled by running make clean; make -f Makefile.python 
This CUTE Makefile is modified to compile a shared library instead of an executable.
CUDA version not implemented and is removed from Makefile.python

The C - Python interface is defined in [CUTEPython.i]

Test the installation by running python2.7 example_cute_python.py (requires the standard CUTE test/ directory in same folder)

Sciama: [ module load apps/python/2.7.8/gcc-4.4.7 ]

=============================================================================
Use:
=============================================================================

The python module allows us to run CUTE from within Python using CUTEPython
All modifications of standard CUTE are inside _CUTE_AS_PYTHON_MODULE defines

Allows to pass a random_catalog and pass it to CUTE to avoid 
having to read this from file every time in case of multiple calls.
 
Input:
   * Filename of CUTE parameterfile (standard CUTE format). If not provided
     then we assume the parameters have been set by first calling set_CUTE_parameters(...)
     defined in the example python script. See also CUTEPython.i for methods one can
     call from python to set the parameters one by one.
   * Random catalog in CUTE format
     If not provided then the random catalog
     is read from file inside CUTE
     The random catalog can be created by calling 
     cute.read_random_catalog(paramfile, random_filename)

Output:
   * [x], [corr]. The [x] depends on the [corr_type] option
     in CUTE. [Dz] for corr_type = radial, [theta] for corr_type = angular
     and [r] for corr_type = monopole. See the CUTE readme for more info. 
     If corr_type is different then we results are just written to file and not
     returned in the arrays below (too lazy to implement this).
     [corr] is the correlation function (radial, angular or monopole).

We can also fetch paircount from [result] if wanted, see CUTEPython.i for 
availiable functions.

Python has responsibillity for the memory of [result] and [random_catalog] (if 
random_catalog != None). Deallocation should be handled automatically, but not tested
so to be sure of no memory leaks we can always call cute.free_result_struct(result) 
and cute.free_Catalog(random_catalog) 

MPI support is implemented, but not well tested. To run with MPI
run as OMP_NUM_THREADS=1 mpirun -np N python2.7 script.py and remember 
to call cute.finalize_mpi() in the end of the script.

TODO: 
  * Should implement returning results for corr_type != "radial", "angular" or "monopole"

  * Should allow for also passing galaxy catalog from Python to CUTE.
    
  * Should allow to also pass a second set of randoms/galaxies in case of use_two_catalogs = True
